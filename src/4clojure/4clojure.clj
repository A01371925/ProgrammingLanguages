(= (conj '(2 3 4) 1))(conj '(2 3 4) 1)(conj '(3 4) 2 1)(set '(:a :a :b :c :c :c :c :d :d))(clojure.set/union #{:a :b :c} #{:b :c :d})(first (rest (reverse '(2 3 4))))(- (count '(2 3 4)) 2)(first '())(fn coeq  [lst]  (loop    [i 0     lst lst]    (if (nil? (first lst))      i      (recur (inc i) (rest lst)))))((fn [x lst]   (some true? (map (fn [y]                      (if (and (= x (first y) (nil? (second y))))                        true                        false)) lst))) :b {:a nil :b 2})((fn [x lst]   (map (fn [y]          (if (and (= x (first y)) (nil? (second y)))            true            false)) lst)) :a {:a nil :b 2})(defn add [e lst]  (into {} (map #(hash-map % e) lst))) (add 0 [:a :b :c])(for [x (range 40)      :when (= 1 (rem x 4))]  x)(if-not false 1 0)(some true? '(false false))(fn rev  [lst]  (loop    [newList '()     oldList lst]    (if (nil? oldList)      oldList      (recur (cons newList (last oldList)) (butlast oldList)))))(loop  [newList '()   oldList '(1 2 3 3 1)]  (if (nil? (first oldList))    newList    (recur (concat newList (list (last oldList))) (butlast oldList))))(defn fib  [n]  (if ( <= n 1)    n    (+ (fib (- n 1)) (fib (- n 2)))))(fib 3)(defn fi  [n]  (loop    [first 1     second 1     lst '(1 1)]    (if (= n (count lst))      lst      (recur        second        (+ first second)        (concat lst (list (+ first second)))))))(defn foo [x] (when (> x 0) (conj (foo (dec x)) x)))(foo 5)(seq '(2 3 4))(reverse '(2 3 4))(vector '(3))(seq 1)(apply str (re-seq #"[A-Z]+" "bA1B3Ce "))(map #(seq %) '((1 2) 3 [4 [5 6]]))(mapcat reverse '([1 2] 3 [4 [5 6]]))(->> [2 5 4 1 3 6] (drop 2) (take 3) (map inc))(fi 6)(range 3)(mapcat (fn fib          [e]          (if ( <= e 1)            e            (+ (fib (- e 1)) (fib (- e 2))))) (range 3))(fn [lst]  (map #(+ % %) lst))(reduce + '(1 2 3 3 1))(filter #(odd? %) '(1 2 3 3 1))(cons (last '(1 2 3 3 1)) '())(fn fib [lst]  (loop    [i 0     lst lst]    (if (nil? (first lst))      i      (recur (inc i)             (rest lst)))))(loop  [i 1   lst '(1 2 3 3 1)]  (if (nil? (first lst))    i    (recur (inc i)           (rest lst))))(fn fib  [n]  (if ( <= n 1)    n    (+ (fib (- n 1)) (fib (- n 2)))))(fib 5)(loop  [i 0   lst '(1 2 3 3 1)]  (if (nil? (first lst))    i    (recur (inc i) (rest lst))))(fn coeq  [lst]  (let [i 1]    (if (nil? (first lst))      i      (coeq (rest lst)))))(coeq '(1 2 3 3 1))(fn nthChild  [lst n]  ())(- (/  8 2) 0) (defn triangle-4    [h]    (let [b (range (- (* 2 h) 1))]     (doseq [i (range h)]       (doseq [j b]         (if (and (>= j (- (/ (last b) 2) j)) (< (- (count b) (- (/ (last b) 2) j))))           (print "*")           (print " ")))       (println) ) )) (triangle-4  5)(>= 0 (- (/ 8 2) 0))(vector 1 2)(let [[a b c d e] [0 1 2 3 4]] (vector c e))(defn v [& lst]  (loop    [max 0     lst lst]    (if (empty? lst)      max      (if (> (first lst) max)        (recur (first lst) (rest lst))        (recur max (rest lst))))))(reduce str (remove #(not (Character/isUpperCase %))        (mapcat (fn [e]                  e) (clojure.string/split "HeLlO, WoRlD!" #""))))(v 12 12 17 15)(fn [x]  (mapcat #(cons % %) x))(mapcat #(list % %) [1 2 3])(some #{2 7 6} [5 6 7 8])(dedupe [1 1 2 3 3 2 2 3])(drop 5 [1 2])           (fn [x y]  (mapcat #(repeat % y) lst))(mapcat #(repeat 2 %) '(1 1 2 2 3 3))(take 5 (iterate #(+ 3 %) 1))(keep #(some->> % (find map-1) key) (keys map-2))(defn key-intersection [s1 s2]  (if (< (count s2) (count s1))    (recur s2 s1)    (reduce      (fn [result item]        (if (contains? s2 item)          (conj result item)          result))      #{}      (keys s1))))(defn key-intersection [s1 s2](if (< (count s2) (count s1))  (recur s2 s1)  (reduce    (fn [result item]      (if (contains? s2 item)        (conj result item)        result))    #{}    (keys s1))))(get #{a b} 0)(key-intersection #{0 1 2 3} #{2 3 4 5})(fn cnt-sqrt [arg]  (let [get-digits (fn [n]                     (map #(Integer/valueOf (str %)) (String/valueOf n)))        digits-sqr (fn [n]                     (apply + (map #(* % %) (get-digits n))))        res-seq (filter #(< % (digits-sqr %)) arg)]    (count res-seq)))(fn [n]  (count (filter #(< % ((fn [n]             (apply + (map (fn [e] (* e e)) ((map (fn [e] (Integer/valueOf (str e))) (String/valueOf n)) n)))) %)) n)))(fn symmetry [[root left right]]  (let [mirror? (fn mirror? [a b]                  (cond                    (not= (sequential? a) (sequential? b)) false                    (sequential? a) (let [[ra La Ra] a                                          [rb Lb Rb] b]                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))                    :else (= a b)))]    (mirror? left right)))(fn [map]  (into {}        (for [[e v] map              [ve vv] v]          (vec [[e ve] vv]))))